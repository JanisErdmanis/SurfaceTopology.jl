<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Intorduction · SurfaceTopology.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SurfaceTopology.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Intorduction</a><ul class="internal"><li><a class="toctext" href="#API-1">API</a></li><li><a class="toctext" href="#Datastructures-1">Datastructures</a></li><li><a class="toctext" href="#Wishlist-1">Wishlist</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Intorduction</a></li></ul><a class="edit-page" href="https://github.com/akels/SurfaceTopology.jl/blob/master/examples/features.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Intorduction</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Intorduction-1" href="#Intorduction-1">Intorduction</a></h1><p>As we know triangular meshes can be stored in a computer in a multiple different ways, each having strength and weaknesses in a particular cases. Not always it is clear which datastructure would be most performant for a numerical algorithm so it is wise to write a datastructure generic code. This package is exactly for that purpose for orriented closed surfaces.</p><p>The simplest representation of triangular mesh topology is in array <code>Array{Faces{3,Int},1}</code> containing a list of triangular faces which are defined by their vertices. Often in a numerical code one wants not only to iterate over faces or vertices, but also in case of singularity substraction, integration and local property estimation like normal vectors and curvature to know what are neighbouring verticies surrounding a given vertex while keeping track of orrientation of the normals. Also one wishes to modify the topology itself by colloapsing, flipingn and splitting edges. This is why different datstructrures are needed for different problems.</p><p>Fortunatelly it is possible to abstract queries of the topology through iterators:</p><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Faces(topology)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Edges(topology)</code>. Check Documenter&#39;s build log for details.</p></div></div><p>and circulators:</p><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>VertexRing(topology,v)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>EdgeRing(topology,v)</code>. Check Documenter&#39;s build log for details.</p></div></div><h2><a class="nav-anchor" id="API-1" href="#API-1">API</a></h2><p>At the moment the package implements three different kinds of datastructures. The simplest one is <code>PlainDS</code> one which stores list of faces and is just an alias to <code>Array{Faces{3,Int},1}</code>. As an example how taht works let&#39;s deffine the datastructure:</p><pre><code class="language-julia">using GeometryTypes
using SurfaceTopology

faces = Face{3,Int64}[
    [1, 12, 6], [1, 6, 2], [1, 2, 8], [1, 8, 11], [1, 11, 12], [2, 6, 10], [6, 12, 5],
    [12, 11, 3], [11, 8, 7], [8, 2, 9], [4, 10, 5], [4, 5, 3], [4, 3, 7], [4, 7, 9],
    [4, 9, 10], [5, 10, 6], [3, 5, 12], [7, 3, 11], [9, 7, 8], [10, 9, 2]
]</code></pre><pre><code class="language-none">20-element Array{GeometryTypes.Face{3,Int64},1}:
 [1, 12, 6] 
 [1, 6, 2]  
 [1, 2, 8]  
 [1, 8, 11] 
 [1, 11, 12]
 [2, 6, 10] 
 [6, 12, 5] 
 [12, 11, 3]
 [11, 8, 7] 
 [8, 2, 9]  
 [4, 10, 5] 
 [4, 5, 3]  
 [4, 3, 7]  
 [4, 7, 9]  
 [4, 9, 10] 
 [5, 10, 6] 
 [3, 5, 12] 
 [7, 3, 11] 
 [9, 7, 8]  
 [10, 9, 2] </code></pre><p>The datastructure <code>faces</code> can be directly used for the queries. The iterators can be executed:</p><pre><code class="language-julia">collect(Faces(faces))</code></pre><pre><code class="language-none">20-element Array{GeometryTypes.Face{3,Int64},1}:
 [1, 12, 6] 
 [1, 6, 2]  
 [1, 2, 8]  
 [1, 8, 11] 
 [1, 11, 12]
 [2, 6, 10] 
 [6, 12, 5] 
 [12, 11, 3]
 [11, 8, 7] 
 [8, 2, 9]  
 [4, 10, 5] 
 [4, 5, 3]  
 [4, 3, 7]  
 [4, 7, 9]  
 [4, 9, 10] 
 [5, 10, 6] 
 [3, 5, 12] 
 [7, 3, 11] 
 [9, 7, 8]  
 [10, 9, 2] </code></pre><p>and</p><pre><code class="language-julia">collect(Edges(faces))</code></pre><pre><code class="language-none">30-element Array{GeometryTypes.Face{2,Int64},1}:
 [1, 12] 
 [1, 6]  
 [1, 2]  
 [2, 8]  
 [1, 8]  
 [8, 11] 
 [1, 11] 
 [11, 12]
 [2, 6]  
 [6, 10] 
 ⋮       
 [4, 9]  
 [9, 10] 
 [5, 10] 
 [3, 5]  
 [5, 12] 
 [3, 11] 
 [7, 8]  
 [8, 9]  
 [2, 10] </code></pre><p>giving us desirable output.</p><p>The circulators which for this simple datastructure requires to do a full lookup on the array can simply be executed as:</p><pre><code class="language-julia">collect(VertexRing(3,faces))</code></pre><pre><code class="language-none">5-element Array{Int64,1}:
 12
  4
  7
  5
 11</code></pre><p>and</p><pre><code class="language-julia">collect(EdgeRing(3,faces))</code></pre><pre><code class="language-none">5-element Array{GeometryTypes.Face{2,Int64},1}:
 [12, 11]
 [4, 5]  
 [7, 4]  
 [5, 12] 
 [11, 7] </code></pre><p>In practice one should use <code>EdgeRing</code> over <code>VertexRing</code> since in the later one vertices are not ordered.</p><h2><a class="nav-anchor" id="Datastructures-1" href="#Datastructures-1">Datastructures</a></h2><p>The same API works for all other datastructures. There is a datastructure <code>CachedDS</code> built on top of <code>PlainDS</code> stores closest vertices (vertex ring). Then there is a datastructure <code>FaceDS</code> which with <code>PlainDS</code> also stores neighbouring faces which have a common edge. And then there are most popular datastructures <code>HalfEdgeDS</code> (implemented as <code>EdgeDS</code>).</p><p>The simplest extension is just a plain caching implemented under <code>CacheDS</code> which for each vertex stores it&#39;s surrounding verticies.</p><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>CachedDS</code>. Check Documenter&#39;s build log for details.</p></div></div><p>which can be initialised from <code>PlainDS</code></p><pre><code class="language-julia">cachedtopology = CachedDS(faces)</code></pre><pre><code class="language-none">CachedDS(GeometryTypes.Face{3,Int64}[[1, 12, 6], [1, 6, 2], [1, 2, 8], [1, 8, 11], [1, 11, 12], [2, 6, 10], [6, 12, 5], [12, 11, 3], [11, 8, 7], [8, 2, 9], [4, 10, 5], [4, 5, 3], [4, 3, 7], [4, 7, 9], [4, 9, 10], [5, 10, 6], [3, 5, 12], [7, 3, 11], [9, 7, 8], [10, 9, 2]], Array{Int64,1}[[6, 2, 8, 11, 12], [6, 10, 9, 8, 1], [11, 7, 4, 5, 12], [5, 3, 7, 9, 10], [12, 3, 4, 10, 6], [12, 5, 10, 2, 1], [8, 9, 4, 3, 11], [2, 9, 7, 11, 1], [2, 10, 4, 7, 8], [6, 5, 4, 9, 2], [8, 7, 3, 12, 1], [1, 11, 3, 5, 6]])</code></pre><p>And the same API can be used for querries:</p><pre><code class="language-julia">collect(VertexRing(3,cachedtopology))</code></pre><pre><code class="language-none">5-element Array{Int64,1}:
 11
  7
  4
  5
 12</code></pre><p>A more advanced datastructure is a face based datastructure which in this library is defined as <code>FaceDS</code> which additionally for each face stores 3 neigbouring face indicies.</p><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>FaceDS</code>. Check Documenter&#39;s build log for details.</p></div></div><p>which again can be initialised from <code>PlainDS</code></p><pre><code class="language-julia">facedstopology = FaceDS(faces)</code></pre><pre><code class="language-none">FaceDS(GeometryTypes.Face{3,Int64}[[1, 12, 6], [1, 6, 2], [1, 2, 8], [1, 8, 11], [1, 11, 12], [2, 6, 10], [6, 12, 5], [12, 11, 3], [11, 8, 7], [8, 2, 9], [4, 10, 5], [4, 5, 3], [4, 3, 7], [4, 7, 9], [4, 9, 10], [5, 10, 6], [3, 5, 12], [7, 3, 11], [9, 7, 8], [10, 9, 2]], GeometryTypes.Face{3,Int64}[[7, 2, 5], [6, 3, 1], [10, 4, 2], [9, 5, 3], [8, 1, 4], [16, 20, 2], [17, 16, 1], [18, 17, 5], [19, 18, 4], [20, 19, 3], [16, 12, 15], [17, 13, 11], [18, 14, 12], [19, 15, 13], [20, 11, 14], [6, 7, 11], [7, 8, 12], [8, 9, 13], [9, 10, 14], [10, 6, 15]], [1, 2, 8, 11, 7, 1, 9, 3, 10, 6, 4, 1])</code></pre><p>and what would one expect</p><pre><code class="language-julia">collect(VertexRing(3,facedstopology))</code></pre><pre><code class="language-none">5-element Array{Int64,1}:
 12
 11
  7
  4
  5</code></pre><p>works.</p><p>The last in the list is half edge datastructure <code>EdgeDS</code> which stores edges with three numbers - base vertex index, next edge index and twin edge index.</p><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>EdgeDS</code>. Check Documenter&#39;s build log for details.</p></div></div><p>To initiate this datastructure one executes:</p><pre><code class="language-julia">edgedstopology = EdgeDS(faces)</code></pre><pre><code class="language-none">EdgeDS(GeometryTypes.Face{3,Int64}[[1, 2, 15], [12, 3, 19], [6, 1, 4], [1, 5, 3], [6, 6, 16], [2, 4, 7], [1, 8, 6], [2, 9, 28], [8, 7, 10], [1, 11, 9]  …  [12, 49, 24], [7, 53, 38], [3, 54, 23], [11, 52, 27], [9, 56, 41], [7, 57, 26], [8, 55, 30], [10, 59, 44], [9, 60, 29], [2, 58, 18]])</code></pre><pre><code class="language-julia">collect(VertexRing(3,edgedstopology))</code></pre><pre><code class="language-none">5-element Array{Int64,1}:
 12
 11
  7
  4
  5</code></pre><h2><a class="nav-anchor" id="Wishlist-1" href="#Wishlist-1">Wishlist</a></h2><p>At the moment the package is able to only answer queries, but it would be desirable to also be able to do topological operations. For completition thoose would include:</p><ul><li><code>edgeflip(topology,edge)</code></li><li><code>edgesplit(topology,edge)</code></li><li><code>edgecollapse(topology,edge)</code></li></ul><p>And with them also a method for <code>defragmenting</code> the topology. Unfortunatelly due to irrelevance of this package for my present research, the development of that on my own will be slow. I hope that clarity and simplicity of this package could serve someone as a first step and so eventually topological operations would be impemented out of necessity.</p><footer><hr/></footer></article></body></html>
