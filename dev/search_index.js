var documenterSearchIndex = {"docs":
[{"location":"#","page":"Intorduction","title":"Intorduction","text":"EditURL = \"https://github.com/akels/SurfaceTopology.jl/blob/master/examples/features.jl\"","category":"page"},{"location":"#Intorduction-1","page":"Intorduction","title":"Intorduction","text":"","category":"section"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"As we know, triangular meshes can be stored in a computer in multiple different ways, each having strength and weaknesses in a particular case at hand. But it is not always clear which data structure would be most suitable for a specific task. Thus it is wise to write a data structure generic code which is the precise purpose of this package for closed oriented closed surfaces.","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"The most straightforward representation of triangular mesh topology is in array Array{Faces{3,Int},1} containing a list of triangular faces which are defined by their vertices. That as name stands allows quick iteration over faces and also edges. However, often in a numerical code one wants not only to iterate over faces or vertices but also in case of singularity subtraction, integration and local property estimation like in normal vector and curvature calculations to know what are neighbouring vertices surrounding a given vertex while keeping track of the orientation of the normals. Also, one wishes to modify the topology itself by collapsing, flipping and splitting edges. And that is why different data structures are needed for different problems.","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"Fortunately, it is possible to abstract mesh topology queries through iterators:","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"Faces\nEdges","category":"page"},{"location":"#SurfaceTopology.Faces","page":"Intorduction","title":"SurfaceTopology.Faces","text":"Faces(t) returns an iterator for faces from representation of topology t\n\n\n\n\n\n","category":"function"},{"location":"#SurfaceTopology.Edges","page":"Intorduction","title":"SurfaceTopology.Edges","text":"Edges(t) returns an iterator for edges from representation of topology t\n\n\n\n\n\n","category":"function"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"and circulators:","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"VertexRing\nEdgeRing","category":"page"},{"location":"#SurfaceTopology.VertexRing","page":"Intorduction","title":"SurfaceTopology.VertexRing","text":"VertexRing(v,t)\n\nConstruct a vertex ring iterator at vertex v from a given topology t. \n\n\n\n\n\n","category":"type"},{"location":"#SurfaceTopology.EdgeRing","page":"Intorduction","title":"SurfaceTopology.EdgeRing","text":"EdgeRing(v,t)\n\nConstruct an edge ring iterator at vertex v from a given topology t. \n\n\n\n\n\n","category":"type"},{"location":"#API-1","page":"Intorduction","title":"API","text":"","category":"section"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"The package implements multiple kinds of data structures. The simplest one is PlainDS one which stores a list of faces and is just an alias to Array{Faces{3,Int},1}. As an example of how that works, let's define the data structure.","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"using GeometryTypes\nusing SurfaceTopology\n\nfaces = Face{3,Int64}[\n    [1, 12, 6], [1, 6, 2], [1, 2, 8], [1, 8, 11], [1, 11, 12], [2, 6, 10], [6, 12, 5],\n    [12, 11, 3], [11, 8, 7], [8, 2, 9], [4, 10, 5], [4, 5, 3], [4, 3, 7], [4, 7, 9],\n    [4, 9, 10], [5, 10, 6], [3, 5, 12], [7, 3, 11], [9, 7, 8], [10, 9, 2]\n]","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"We can use the data structure PlainDS for the queries. The iterators, for example.","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"collect(Faces(faces))","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"and","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"collect(Edges(faces))","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"giving us desirable output.","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"We can also ask what neighbouring vertices and edges for a particular vertex by using circulators. For this simple data structure that requires us to do a full lookup on the face list, which is nicely abstracted away:","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"collect(VertexRing(3,faces))","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"and","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"collect(EdgeRing(3,faces))","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"In practice, one should use EdgeRing over VertexRing since, in the latter one, vertices are not ordered and thus can not be used for example to deduce the direction of the normal vector.","category":"page"},{"location":"#Data-structures-1","page":"Intorduction","title":"Data structures","text":"","category":"section"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"The same API works for all other data structures. There is a data structure CachedDS built on top of PlainDS stores closest vertices (vertex ring). Then there is a data structure FaceDS which with PlainDS also stores neighbouring faces which have a common edge. And then there is the most commonly used data structure in numerics HalfEdgeDS (implemented as EdgeDS).","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"The most straightforward extension of PlainDS is just a plain caching of neighbouring vertices for each vertex which are stored in CacheDS also with the list of faces.","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"CachedDS\nCachedDS(::SurfaceTopology.PlainDS)","category":"page"},{"location":"#SurfaceTopology.CachedDS","page":"Intorduction","title":"SurfaceTopology.CachedDS","text":"A datastructure which in addition to a list of faces stores connectivity information for each vertex.\n\n\n\n\n\n","category":"type"},{"location":"#SurfaceTopology.CachedDS-Tuple{Array{GeometryTypes.Face{3,Int64},1}}","page":"Intorduction","title":"SurfaceTopology.CachedDS","text":"CacheDS(t)\n\nConstructs cached face based datastructure CachedDS from arbitrary topology t which provides EdgeRing iterator. \n\n\n\n\n\n","category":"method"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"which can be initialised from PlainDS","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"cachedtopology = CachedDS(faces)","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"And the same API can be used for querries:","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"collect(VertexRing(3,cachedtopology))","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"A more advanced data structure is a face based data structure FaceDS which additionally for each face stores three neighbouring face indices.","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"FaceDS\nFaceDS(::SurfaceTopology.PlainDS)","category":"page"},{"location":"#SurfaceTopology.FaceDS","page":"Intorduction","title":"SurfaceTopology.FaceDS","text":"A face based datastructure storing faces, neighbour face indices and vertex to face map arrays. \n\n\n\n\n\n","category":"type"},{"location":"#SurfaceTopology.FaceDS-Tuple{Array{GeometryTypes.Face{3,Int64},1}}","page":"Intorduction","title":"SurfaceTopology.FaceDS","text":"FaceDS(faces::PlainDS)\n\nConstructs a face based datastructure from PlainDS. Returns a struct FaceDS with original faces, computed neighbour faces and vertex to face map (one face for each vertex).  \n\n\n\n\n\n","category":"method"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"which again can be initialised from PlainDS","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"facedstopology = FaceDS(faces)","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"and what would one expect","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"collect(VertexRing(3,facedstopology))","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"works.","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"All previous ones were some forms of face-based data structures. More common (by my own impression) the numerical world uses edge-based data structures. This package implements half-edge data structure EdgeDS which stores a list of edges by three numbers - base vertex index, next edge index and twin edge index.","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"EdgeDS","category":"page"},{"location":"#SurfaceTopology.EdgeDS","page":"Intorduction","title":"SurfaceTopology.EdgeDS","text":"EdgeDS(faces::PlainDS)\n\nConstructs and returns edge based datastructure EdgeDS from plain face based datastructure PlainDS. Half edge based datastructure EdgeDS stores list of edges consisting of base vertex, next edge index and twin edge index.\n\n\n\n\n\n","category":"type"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"To initialise this datastructure one executes:","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"edgedstopology = EdgeDS(faces)","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"collect(VertexRing(3,edgedstopology))","category":"page"},{"location":"#Wishlist-1","page":"Intorduction","title":"Wishlist","text":"","category":"section"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"At the moment the package is able only to answer queries, but it would be desirable also to be able to do topological surgery operations. For completeness, those would include.","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"edgeflip(topology,edge)\nedgesplit(topology,edge)\nedgecollapse(topology,edge)","category":"page"},{"location":"#","page":"Intorduction","title":"Intorduction","text":"And with them even a method for defragmenting the topology (actually trivial if we generalize constructors as in CachedDS). Unfortunately, at the moment, I am not working with anything geometry related thus the development of that on my own will be slow. I hope that the clarity and simplicity of this package could serve someone as a first step, and so eventually, topological operations would be implemented out of necessity.","category":"page"}]
}
